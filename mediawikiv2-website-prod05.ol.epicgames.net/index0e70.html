<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from mediawikiv2-website-prod05.ol.epicgames.net/index.php?title=Authoritative_Networked_Character_Movement by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 01 Apr 2020 00:58:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/><script type="text/javascript">(window.NREUM||(NREUM={})).loader_config={licenseKey:"93a8bd5691",applicationID:"145396307"};window.NREUM||(NREUM={}),__nr_require=function(e,n,t){function r(t){if(!n[t]){var i=n[t]={exports:{}};e[t][0].call(i.exports,function(n){var i=e[t][1][n];return r(i||n)},i,i.exports)}return n[t].exports}if("function"==typeof __nr_require)return __nr_require;for(var i=0;i<t.length;i++)r(t[i]);return r}({1:[function(e,n,t){function r(){}function i(e,n,t){return function(){return o(e,[u.now()].concat(f(arguments)),n?null:this,t),n?void 0:this}}var o=e("handle"),a=e(4),f=e(5),c=e("ee").get("tracer"),u=e("loader"),s=NREUM;"undefined"==typeof window.newrelic&&(newrelic=s);var p=["setPageViewName","setCustomAttribute","setErrorHandler","finished","addToTrace","inlineHit","addRelease"],l="api-",d=l+"ixn-";a(p,function(e,n){s[n]=i(l+n,!0,"api")}),s.addPageAction=i(l+"addPageAction",!0),s.setCurrentRouteName=i(l+"routeName",!0),n.exports=newrelic,s.interaction=function(){return(new r).get()};var m=r.prototype={createTracer:function(e,n){var t={},r=this,i="function"==typeof n;return o(d+"tracer",[u.now(),e,t],r),function(){if(c.emit((i?"":"no-")+"fn-start",[u.now(),r,i],t),i)try{return n.apply(this,arguments)}catch(e){throw c.emit("fn-err",[arguments,this,e],t),e}finally{c.emit("fn-end",[u.now()],t)}}}};a("actionText,setName,setAttribute,save,ignore,onEnd,getContext,end,get".split(","),function(e,n){m[n]=i(d+n)}),newrelic.noticeError=function(e,n){"string"==typeof e&&(e=new Error(e)),o("err",[e,u.now(),!1,n])}},{}],2:[function(e,n,t){function r(e,n){var t=e.getEntries();t.forEach(function(e){"first-paint"===e.name?c("timing",["fp",Math.floor(e.startTime)]):"first-contentful-paint"===e.name&&c("timing",["fcp",Math.floor(e.startTime)])})}function i(e,n){var t=e.getEntries();t.length>0&&c("lcp",[t[t.length-1]])}function o(e){if(e instanceof s&&!l){var n,t=Math.round(e.timeStamp);n=t>1e12?Date.now()-t:u.now()-t,l=!0,c("timing",["fi",t,{type:e.type,fid:n}])}}if(!("init"in NREUM&&"page_view_timing"in NREUM.init&&"enabled"in NREUM.init.page_view_timing&&NREUM.init.page_view_timing.enabled===!1)){var a,f,c=e("handle"),u=e("loader"),s=NREUM.o.EV;if("PerformanceObserver"in window&&"function"==typeof window.PerformanceObserver){a=new PerformanceObserver(r),f=new PerformanceObserver(i);try{a.observe({entryTypes:["paint"]}),f.observe({entryTypes:["largest-contentful-paint"]})}catch(p){}}if("addEventListener"in document){var l=!1,d=["click","keydown","mousedown","pointerdown","touchstart"];d.forEach(function(e){document.addEventListener(e,o,!1)})}}},{}],3:[function(e,n,t){function r(e,n){if(!i)return!1;if(e!==i)return!1;if(!n)return!0;if(!o)return!1;for(var t=o.split("."),r=n.split("."),a=0;a<r.length;a++)if(r[a]!==t[a])return!1;return!0}var i=null,o=null,a=/Version\/(\S+)\s+Safari/;if(navigator.userAgent){var f=navigator.userAgent,c=f.match(a);c&&f.indexOf("Chrome")===-1&&f.indexOf("Chromium")===-1&&(i="Safari",o=c[1])}n.exports={agent:i,version:o,match:r}},{}],4:[function(e,n,t){function r(e,n){var t=[],r="",o=0;for(r in e)i.call(e,r)&&(t[o]=n(r,e[r]),o+=1);return t}var i=Object.prototype.hasOwnProperty;n.exports=r},{}],5:[function(e,n,t){function r(e,n,t){n||(n=0),"undefined"==typeof t&&(t=e?e.length:0);for(var r=-1,i=t-n||0,o=Array(i<0?0:i);++r<i;)o[r]=e[n+r];return o}n.exports=r},{}],6:[function(e,n,t){n.exports={exists:"undefined"!=typeof window.performance&&window.performance.timing&&"undefined"!=typeof window.performance.timing.navigationStart}},{}],ee:[function(e,n,t){function r(){}function i(e){function n(e){return e&&e instanceof r?e:e?c(e,f,o):o()}function t(t,r,i,o){if(!l.aborted||o){e&&e(t,r,i);for(var a=n(i),f=v(t),c=f.length,u=0;u<c;u++)f[u].apply(a,r);var p=s[y[t]];return p&&p.push([b,t,r,a]),a}}function d(e,n){h[e]=v(e).concat(n)}function m(e,n){var t=h[e];if(t)for(var r=0;r<t.length;r++)t[r]===n&&t.splice(r,1)}function v(e){return h[e]||[]}function g(e){return p[e]=p[e]||i(t)}function w(e,n){u(e,function(e,t){n=n||"feature",y[t]=n,n in s||(s[n]=[])})}var h={},y={},b={on:d,addEventListener:d,removeEventListener:m,emit:t,get:g,listeners:v,context:n,buffer:w,abort:a,aborted:!1};return b}function o(){return new r}function a(){(s.api||s.feature)&&(l.aborted=!0,s=l.backlog={})}var f="nr@context",c=e("gos"),u=e(4),s={},p={},l=n.exports=i();l.backlog=s},{}],gos:[function(e,n,t){function r(e,n,t){if(i.call(e,n))return e[n];var r=t();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(e,n,{value:r,writable:!0,enumerable:!1}),r}catch(o){}return e[n]=r,r}var i=Object.prototype.hasOwnProperty;n.exports=r},{}],handle:[function(e,n,t){function r(e,n,t,r){i.buffer([e],r),i.emit(e,n,t)}var i=e("ee").get("handle");n.exports=r,r.ee=i},{}],id:[function(e,n,t){function r(e){var n=typeof e;return!e||"object"!==n&&"function"!==n?-1:e===window?0:a(e,o,function(){return i++})}var i=1,o="nr@id",a=e("gos");n.exports=r},{}],loader:[function(e,n,t){function r(){if(!x++){var e=E.info=NREUM.info,n=d.getElementsByTagName("script")[0];if(setTimeout(s.abort,3e4),!(e&&e.licenseKey&&e.applicationID&&n))return s.abort();u(y,function(n,t){e[n]||(e[n]=t)}),c("mark",["onload",a()+E.offset],null,"api");var t=d.createElement("script");t.src="https://"+e.agent,n.parentNode.insertBefore(t,n)}}function i(){"complete"===d.readyState&&o()}function o(){c("mark",["domContent",a()+E.offset],null,"api")}function a(){return O.exists&&performance.now?Math.round(performance.now()):(f=Math.max((new Date).getTime(),f))-E.offset}var f=(new Date).getTime(),c=e("handle"),u=e(4),s=e("ee"),p=e(3),l=window,d=l.document,m="addEventListener",v="attachEvent",g=l.XMLHttpRequest,w=g&&g.prototype;NREUM.o={ST:setTimeout,SI:l.setImmediate,CT:clearTimeout,XHR:g,REQ:l.Request,EV:l.Event,PR:l.Promise,MO:l.MutationObserver};var h=""+location,y={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",agent:"js-agent.newrelic.com/nr-1167.min.js"},b=g&&w&&w[m]&&!/CriOS/.test(navigator.userAgent),E=n.exports={offset:f,now:a,origin:h,features:{},xhrWrappable:b,userAgent:p};e(1),e(2),d[m]?(d[m]("DOMContentLoaded",o,!1),l[m]("load",r,!1)):(d[v]("onreadystatechange",i),l[v]("onload",r)),c("mark",["firstbyte",f],null,"api");var x=0,O=e(6)},{}],"wrap-function":[function(e,n,t){function r(e){return!(e&&e instanceof Function&&e.apply&&!e[a])}var i=e("ee"),o=e(5),a="nr@original",f=Object.prototype.hasOwnProperty,c=!1;n.exports=function(e,n){function t(e,n,t,i){function nrWrapper(){var r,a,f,c;try{a=this,r=o(arguments),f="function"==typeof t?t(r,a):t||{}}catch(u){l([u,"",[r,a,i],f])}s(n+"start",[r,a,i],f);try{return c=e.apply(a,r)}catch(p){throw s(n+"err",[r,a,p],f),p}finally{s(n+"end",[r,a,c],f)}}return r(e)?e:(n||(n=""),nrWrapper[a]=e,p(e,nrWrapper),nrWrapper)}function u(e,n,i,o){i||(i="");var a,f,c,u="-"===i.charAt(0);for(c=0;c<n.length;c++)f=n[c],a=e[f],r(a)||(e[f]=t(a,u?f+i:i,o,f))}function s(t,r,i){if(!c||n){var o=c;c=!0;try{e.emit(t,r,i,n)}catch(a){l([a,t,r,i])}c=o}}function p(e,n){if(Object.defineProperty&&Object.keys)try{var t=Object.keys(e);return t.forEach(function(t){Object.defineProperty(n,t,{get:function(){return e[t]},set:function(n){return e[t]=n,n}})}),n}catch(r){l([r])}for(var i in e)f.call(e,i)&&(n[i]=e[i]);return n}function l(n){try{e.emit("internal-error",n)}catch(t){}}return e||(e=i),t.inPlace=u,t.flag=a,t}},{}]},{},["loader"]);</script>
<title>Authoritative Networked Character Movement - Epic Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Authoritative_Networked_Character_Movement","wgTitle":"Authoritative Networked Character Movement","wgCurRevisionId":321,"wgRevisionId":321,"wgArticleId":160,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Tutorials","Code","Community Created Content"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Authoritative_Networked_Character_Movement","wgRelevantArticleId":160,"wgRequestId":"7d227890ae02f3f9c306230d","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"loading","user.tokens":"loading","ext.pygments":"ready","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.options@0bhc5ha",function($,jQuery,require,module){mw.user.options.set([]);});mw.loader.implement("user.tokens@071vexb",function ( $, jQuery, require, module ) {
mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});/*@nomin*/

});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="load9239.css?debug=false&amp;lang=en&amp;modules=ext.pygments%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="load2c8d.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<meta name="generator" content="MediaWiki 1.30.0"/>
<link rel="shortcut icon" href="favicon.html"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="Epic Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api-result251f.xml?action=rsd"/>
<link rel="license" href="https://www.epicgames.com/tos"/>
<link rel="alternate" type="application/atom+xml" title="Epic Wiki Atom feed" href="feeda295.xml?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/resources/lib/html5shiv/html5shiv.min.js?40bd4"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Authoritative_Networked_Character_Movement rootpage-Authoritative_Networked_Character_Movement skin-vector action-view"><!DOCTYPE html><html data-baseurl="https://www.unrealengine.com"><head><meta charSet="UTF-8"><meta httpEquiv="X-UA-Compatible" content="IE=9;IE=10;IE=11;IE=Edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui"><meta name="host" content="ue-website-node-prod07-i-0e33288c51e7947d3"><meta name="worker" content="134"><link rel="apple-touch-icon" sizes="180x180" href="indexfb0b.html"><link rel="icon" type="image/png" sizes="32x32" href="index4aa2.html"><link rel="icon" type="image/png" sizes="16x16" href="indexca83.html"><link rel="manifest" href="index38c2.html"><link rel="mask-icon" href="indexebf0.html" color="#2a2a2a"><meta name="apple-mobile-web-app-title" content="Unreal Engine"><meta name="application-name" content="Unreal Engine"><meta name="msapplication-TileColor" content="#0aaff1"><meta name="msapplication-TileImage" content="/mstile-144x144.png"><meta name="theme-color" content="#0aaff1"><title data-react-helmet="true"></title></head><body><div id="epicGamesNavigation"></div><script>(function () {
    var config = {"serverUrl":"https://www.unrealengine.com","locale":"en-US","localeOptions":[{"lang":"en-US","name":"English"},{"lang":"ko","name":"한국어"},{"lang":"ja","name":"日本語"},{"lang":"zh-CN","name":"简体中文"}],"euCookieStrings":{"cookieString":"We use cookies to ensure the best experience on all Epic Games websites. To learn more, please see our {0}.","policyString":"privacy policy","closeString":"Close","policyUrl":"https://www.epicgames.com/privacypolicy"},"_currentVersion":"1.37.2.101.61.0.1","_type":"Epic Games Nav","hideSignIn":true,"_lastModifiedBy":"tony.rossi","epicPropertyName":"unreal_engine","pcDownloadUrl":"https://launcher-public-service-prod06.ol.epicgames.com/launcher/api/installer/download/EpicGamesLauncherInstaller.msi?productName=unrealengine","_createdBy":"tony.rossi","_uuid":"a0357fbf-1bd5-4eca-bbbf-48ea56e4ddb1","callToAction":{"_type":"Epic Header Call To Action","useCustomCallback":true,"href":"http://unrealengine.com/register","title":"Download"},"hideCallToAction":false,"hideLocale":true,"accountLinks":{"signOutLink":{"_type":"Epic Header Action Link","useCustomCallback":true,"href":"http://unrealengine.com/logout","key":"signout"},"dropdownLinks":[{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"http://unrealengine.com/account/personal?lang=en-US","title":"Personal","key":"personal"},{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"https://publish.unrealengine.com","title":"Seller","key":"seller"}],"signInLinks":[{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/id/login","title":"Sign In","key":"signin"}],"_type":"Epic Header Account Links"},"logoLink":{"_type":"Epic Header Action Link","useCustomCallback":true,"href":"http://unrealengine.com/","key":"logo"},"_futureVersion":"none","_created":"2017-08-21T08:59:33.648Z","_activeDate":"2019-05-31T08:22:43.049Z","macDownloadUrl":"https://launcher-public-service-prod06.ol.epicgames.com/launcher/api/installer/download/EpicGamesLauncher.dmg?productName=unrealengine","messages":{"search":"Search","default_download":"Get Epic Games","default_username":"Account","_type":"Epic Header Messages","locale":"English","sign_in":"Sign In","sign_out":"Sign Out"},"links":[{"isBarDivider":false,"_type":"Epic Header Link","useCustomCallback":true,"href":"http://unrealengine.com/blog","title":"News","key":"blog"},{"isBarDivider":false,"_type":"Epic Header Link","useCustomCallback":false,"title":"About","key":"about","kids":[{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/features","title":"Features"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/release-notes/","title":"What's New"},{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"https://trello.com/b/TTAVI7Ny/ue4-roadmap","title":"Roadmap","target":"_blank"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/faq","title":"FAQ"}]},{"isBarDivider":false,"_type":"Epic Header Link","collapseTarget":"More","useCustomCallback":false,"title":"Industries","key":"industries","kids":[{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/industry/games","title":"Games"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/architecture-solution","title":"Architecture"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/industry/automotive-transportation","title":"Automotive & Transportation"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/industry/broadcast-live-events","title":"Broadcast & Live Events"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/industry/film-television","title":"Film & Television"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/industry/training-simulation","title":"Training & Simulation"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/industry/more-uses","title":"More Uses"}]},{"isBarDivider":false,"_type":"Epic Header Link","collapseTarget":"More","useCustomCallback":false,"title":"Learning & Support","key":"learn","kids":[{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/learn","title":"Get Started"},{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"https://docs.unrealengine.com/","title":"Documentation"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/onlinelearning-courses","title":"Online Learning","key":""},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/events/webinar-series","title":"Webinars"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/education","title":"Education"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/support","title":"Support"},{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"https://issues.unrealengine.com/","title":"Issues"}]},{"isBarDivider":false,"_type":"Epic Header Link","collapseTarget":"More","useCustomCallback":false,"title":"Community","key":"community","kids":[{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"https://forums.unrealengine.com/","title":"Forums"},{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"https://answers.unrealengine.com/","title":"AnswerHub"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/megagrants","title":"MegaGrants","key":""},{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"https://communities.unrealengine.com","title":"User Groups"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/events","title":"Events"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/programs/nvidia-edge","title":"Nvidia Edge","key":"programs"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/programs/intel-unreal","title":"Intel + Unreal","key":""}]},{"isBarDivider":false,"_type":"Epic Header Link","collapseTarget":"More","useCustomCallback":false,"title":"Marketplace","key":"marketplace","kids":[{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"http://unrealengine.com/marketplace","title":"Browse"},{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"https://publish.unrealengine.com/","title":"Submit Content"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/marketplace-faq","title":"Marketplace FAQ"},{"_type":"Epic Header Submenu Item","useCustomCallback":true,"href":"http://unrealengine.com/marketplace-guidelines","title":"Marketplace Guidelines"},{"_type":"Epic Header Submenu Item","useCustomCallback":false,"href":"https://forums.unrealengine.com/forumdisplay.php?56-Marketplace","title":"Marketplace Forums"}]}],"hideSearch":false,"_lastModified":"2020-01-30T21:35:59.869Z","_version":{"_comment":"Publish to server UnrealEngine.com (Production)","_createdBy":"tony.rossi"},"_locale":"en_US","useServerUrl":true,"isEu":false};

    if (typeof window._egNavBeforeConfigSet === 'function') {
        window._egNavBeforeConfigSet();
        window._egNavBeforeConfigSetRun = true;
    }
    window._egNavBeforeConfigSetCalled = true;

    if (typeof window._epicGamesNav === 'undefined') {
        window._epicGamesNav = config;
    } else {
        var missingAssumeFalsey = ['hideLocale', 'hideSearch', 'hideSignIn', 'hideCallToAction'];
        for (var key in config) {
            if (typeof key === 'string') {
                if (!window._epicGamesNav[key] && config[key] !== null && missingAssumeFalsey.indexOf(key) === -1) {
                    window._epicGamesNav[key] = config[key];
                }
            }
        }
    }

    window._epicGamesNav.onSearch = function(query) {
        window.location.href = 'https://www.unrealengine.com' + '/bing-search?keyword=' + query;
    };

    if (typeof window._egNavAfterConfigSet === 'function') {
        window._egNavAfterConfigSet();
        window._egNavAfterConfigSetRun = true;
    }
    window._egNavAfterConfigSetCalled = true;
})();
window.__locale = '';
</script><link key="header-css" rel="stylesheet" href="../static-assets-prod.epicgames.com/unrealengine/static/webpack/header.epic-unreal-engine.5ace4ab88c6f6357685f.css"><script src="../static-assets-prod.epicgames.com/unrealengine/static/webpack/header.epic-unreal-engine.5ace4ab88c6f6357685f.js"></script></body>
<!-- Mirrored from mediawikiv2-website-prod05.ol.epicgames.net/index.php?title=Authoritative_Networked_Character_Movement by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 01 Apr 2020 00:58:11 GMT -->
</html>		<div class="container">
			<div id="mw-navigation">
				<h2>Navigation menu</h2>

				<div id="mw-head">
					<!-- 					<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="/index.php?title=Special:UserLogin&amp;returnto=Authoritative+Networked+Character+Movement" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
					 -->
					<div class="homelink_container">
                        <a href="index.html" title="UE4 Wiki Home" class="homelink">HOME</a>
                    </div>
                    <div class="notice">
                    	We have temporarily disabled editing while we're working on a new Wiki!
                    </div>
					<div id="left-navigation">
											<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
														<li id="ca-nstab-main" class="selected"><span><a href="index0e70.html?title=Authoritative_Networked_Character_Movement" title="View the content page [c]" accesskey="c">Page</a></span></li>
							<li id="ca-talk" class="new"><span><a href="indexa745.html?title=Talk:Authoritative_Networked_Character_Movement&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										</div>
					<div id="right-navigation">
											<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
														<li id="ca-view" class="selected"><span><a href="index0e70.html?title=Authoritative_Networked_Character_Movement">Read</a></span></li>
							<li id="ca-viewsource"><span><a href="index5ef3.html?title=Authoritative_Networked_Character_Movement&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
							<li id="ca-history" class="collapsible"><span><a href="indexbc61.html?title=Authoritative_Networked_Character_Movement&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span></h3>

						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>

						<form action="https://mediawikiv2-website-prod05.ol.epicgames.net/index.php" id="searchform">
							<div id="simpleSearch">
							<input type="search" name="search" placeholder="Search Epic Wiki" title="Search Epic Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
										</div>
				</div>
				
			</div>
			<div id="content" class="mw-body" role="main">
				<a id="top"></a>

								<div class="mw-indicators mw-body-content">
</div>
				<h1 id="firstHeading" class="firstHeading" lang="en">Authoritative Networked Character Movement</h1>
												<div id="bodyContent" class="mw-body-content">
											<div id="siteSub" class="noprint">From Epic Wiki</div>
										
															<div id="jump-to-nav" class="mw-jump">
						Jump to:						<a href="#mw-head">navigation</a>, 						<a href="#p-search">search</a>
					</div>
					<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><p><a href="index5e77.html?title=Template:Rating&amp;action=edit&amp;redlink=1" class="new" title="Template:Rating (page does not exist)">Template:Rating</a>
</p><p>Original Author: <a href="index2007.html?title=User:DarthCoder&amp;action=edit&amp;redlink=1" class="new" title="User:DarthCoder (page does not exist)">DarthCoder</a> (<a href="index7570.html?title=User_talk:DarthCoder&amp;action=edit&amp;redlink=1" class="new" title="User talk:DarthCoder (page does not exist)">talk</a>)
</p><p>Implementing proper authoritative character movement is a very complex, yet under documented task. This tutorial serves as an introduction to implementing networked movement features in Unreal 4 by extending the <a rel="nofollow" class="external text" href="https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/GameFramework/UCharacterMovementComponent/index.html">UCharacterMovementComponent</a>. This will be an intermediate to advanced tutorial, and will require using C++ since saved moves do not appear to be supported in Blueprint. Most of my knowledge of the character movement system comes from the Unreal Tournament 4 source code, so some similarities will be apparent.
</p>
<div id="toc" class="toc"><div class="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Initial_Setup"><span class="tocnumber">1</span> <span class="toctext">Initial Setup</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Implementing_Movement_Abilities"><span class="tocnumber">2</span> <span class="toctext">Implementing Movement Abilities</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Sprint"><span class="tocnumber">2.1</span> <span class="toctext">Sprint</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="#Unlimited_Sprint"><span class="tocnumber">2.1.1</span> <span class="toctext">Unlimited Sprint</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#Only_Sprint_Forward"><span class="tocnumber">2.1.2</span> <span class="toctext">Only Sprint Forward</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-6"><a href="#Boost_Dodge"><span class="tocnumber">2.2</span> <span class="toctext">Boost Dodge</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Double_Jump"><span class="tocnumber">2.3</span> <span class="toctext">Double Jump</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#Cooldown_Timers"><span class="tocnumber">3</span> <span class="toctext">Cooldown Timers</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#Conclusion"><span class="tocnumber">4</span> <span class="toctext">Conclusion</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Other_Resources"><span class="tocnumber">5</span> <span class="toctext">Other Resources</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Initial_Setup">Initial Setup</span></h2>
<p>To implement custom networked character movement, you must extend the <a rel="nofollow" class="external text" href="https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/GameFramework/UCharacterMovementComponent/index.html">UCharacterMovementComponent</a> and saved move classes. For starters let's get a class setup with all the boilerplate code out of the way. (thanks to antsonthetree for providing the code to fix this for the latest Unreal 4 version)
<a href="index3d7a.html?title=File:Create-character-movement-class.jpg" class="image"><img alt="Create-character-movement-class.jpg" src="../d26ilriwvtzlb.cloudfront.net/b/b5/Create-character-movement-class.jpg" width="950" height="574" /></a>
</p><p><i>MyCharacterMovement.h</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&quot;GameFramework/CharacterMovementComponent.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;MyCharacterMovement.generated.h&quot;</span><span class="cp"></span>

<span class="n">UCLASS</span><span class="p">()</span>
<span class="k">class</span> <span class="nc">UMyCharacterMovement</span> <span class="o">:</span> <span class="k">public</span> <span class="n">UCharacterMovementComponent</span>
<span class="p">{</span>
	<span class="n">GENERATED_UCLASS_BODY</span><span class="p">()</span>

	<span class="c1">//============================================================================================</span>
	<span class="c1">//Replication</span>
	<span class="c1">//============================================================================================</span>

<span class="k">public</span><span class="o">:</span>

	<span class="k">friend</span> <span class="k">class</span> <span class="nc">FSavedMove_ExtendedMyMovement</span><span class="p">;</span>

	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">UpdateFromCompressedFlags</span><span class="p">(</span><span class="n">uint8</span> <span class="n">Flags</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

	<span class="k">virtual</span> <span class="k">class</span> <span class="nc">FNetworkPredictionData_Client</span><span class="o">*</span> <span class="nf">GetPredictionData_Client</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FSavedMove_MyMovement</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FSavedMove_Character</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

	<span class="k">typedef</span> <span class="n">FSavedMove_Character</span> <span class="n">Super</span><span class="p">;</span>

	<span class="c1">///@brief Resets all saved variables.</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Clear</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

	<span class="c1">///@brief Store input commands in the compressed flags.</span>
	<span class="k">virtual</span> <span class="n">uint8</span> <span class="nf">GetCompressedFlags</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

	<span class="c1">///@brief This is used to check whether or not two moves can be combined into one.</span>
	<span class="c1">///Basically you just check to make sure that the saved variables are the same.</span>
	<span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">CanCombineWith</span><span class="p">(</span><span class="k">const</span> <span class="n">FSavedMovePtr</span><span class="o">&amp;</span> <span class="n">NewMove</span><span class="p">,</span> <span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">MaxDelta</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

	<span class="c1">///@brief Sets up the move before sending it to the server. </span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">SetMoveFor</span><span class="p">(</span><span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">FVector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="k">class</span> <span class="nc">FNetworkPredictionData_Client_Character</span> <span class="o">&amp;</span> <span class="n">ClientData</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="c1">///@brief Sets variables on character movement component before making a predictive correction.</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PrepMoveFor</span><span class="p">(</span><span class="k">class</span> <span class="nc">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FNetworkPredictionData_Client_MyMovement</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FNetworkPredictionData_Client_Character</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
        <span class="n">FNetworkPredictionData_Client_MyMovement</span><span class="p">(</span><span class="k">const</span> <span class="n">UCharacterMovementComponent</span><span class="o">&amp;</span> <span class="n">ClientMovement</span><span class="p">);</span>

	<span class="k">typedef</span> <span class="n">FNetworkPredictionData_Client_Character</span> <span class="n">Super</span><span class="p">;</span>

	<span class="c1">///@brief Allocates a new copy of our custom saved move</span>
	<span class="k">virtual</span> <span class="n">FSavedMovePtr</span> <span class="nf">AllocateNewMove</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;MyCharacterMovement.h&quot;</span><span class="cp"></span>

<span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">UMyCharacterMovement</span><span class="p">(</span><span class="k">const</span> <span class="n">FObjectInitializer</span><span class="o">&amp;</span> <span class="n">ObjectInitializer</span><span class="p">)</span>
	<span class="o">:</span><span class="n">Super</span><span class="p">(</span><span class="n">ObjectInitializer</span><span class="p">)</span>
<span class="p">{</span>
	
<span class="p">}</span>

<span class="c1">//============================================================================================</span>
<span class="c1">//Replication</span>
<span class="c1">//============================================================================================</span>

<span class="c1">//Set input flags on character from saved inputs</span>
<span class="kt">void</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">UpdateFromCompressedFlags</span><span class="p">(</span><span class="n">uint8</span> <span class="n">Flags</span><span class="p">)</span><span class="c1">//Client only</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">UpdateFromCompressedFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">);</span>

	
<span class="p">}</span>

<span class="k">class</span> <span class="nc">FNetworkPredictionData_Client</span><span class="o">*</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">GetPredictionData_Client</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="n">check</span><span class="p">(</span><span class="n">PawnOwner</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">check</span><span class="p">(</span><span class="n">PawnOwner</span><span class="o">-&gt;</span><span class="n">Role</span> <span class="o">&lt;</span> <span class="n">ROLE_Authority</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ClientPredictionData</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">MutableThis</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

		<span class="n">MutableThis</span><span class="o">-&gt;</span><span class="n">ClientPredictionData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FNetworkPredictionData_Client_MyMovement</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
		<span class="n">MutableThis</span><span class="o">-&gt;</span><span class="n">ClientPredictionData</span><span class="o">-&gt;</span><span class="n">MaxSmoothNetUpdateDist</span> <span class="o">=</span> <span class="mf">92.f</span><span class="p">;</span>
		<span class="n">MutableThis</span><span class="o">-&gt;</span><span class="n">ClientPredictionData</span><span class="o">-&gt;</span><span class="n">NoSmoothNetUpdateDist</span> <span class="o">=</span> <span class="mf">140.f</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ClientPredictionData</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">Clear</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">Clear</span><span class="p">();</span>

	
<span class="p">}</span>

<span class="n">uint8</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">GetCompressedFlags</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="n">uint8</span> <span class="n">Result</span> <span class="o">=</span> <span class="n">Super</span><span class="o">::</span><span class="n">GetCompressedFlags</span><span class="p">();</span>


	<span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="k">const</span> <span class="n">FSavedMovePtr</span><span class="o">&amp;</span> <span class="n">NewMove</span><span class="p">,</span> <span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">MaxDelta</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>

	<span class="k">return</span> <span class="n">Super</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="n">NewMove</span><span class="p">,</span> <span class="n">Character</span><span class="p">,</span> <span class="n">MaxDelta</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">FVector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="k">class</span> <span class="nc">FNetworkPredictionData_Client_Character</span> <span class="o">&amp;</span> <span class="n">ClientData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">Character</span><span class="p">,</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="n">ClientData</span><span class="p">);</span>

	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">CharMov</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Character</span><span class="o">-&gt;</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CharMov</span><span class="p">)</span>
	<span class="p">{</span>
		
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">PrepMoveFor</span><span class="p">(</span><span class="k">class</span> <span class="nc">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">PrepMoveFor</span><span class="p">(</span><span class="n">Character</span><span class="p">);</span>

	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">CharMov</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Character</span><span class="o">-&gt;</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CharMov</span><span class="p">)</span>
	<span class="p">{</span>
		
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">FNetworkPredictionData_Client_MyMovement</span><span class="o">::</span><span class="n">FNetworkPredictionData_Client_MyMovement</span><span class="p">(</span><span class="k">const</span> <span class="n">UCharacterMovementComponent</span><span class="o">&amp;</span> <span class="n">ClientMovement</span><span class="p">)</span>
<span class="o">:</span> <span class="n">Super</span><span class="p">(</span><span class="n">ClientMovement</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>

<span class="n">FSavedMovePtr</span> <span class="n">FNetworkPredictionData_Client_MyMovement</span><span class="o">::</span><span class="n">AllocateNewMove</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">FSavedMovePtr</span><span class="p">(</span><span class="k">new</span> <span class="n">FSavedMove_MyMovement</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
<p>In order to actually use the custom component we'll have to set the default subobject class in the character class constructor.
</p><p><i>MyCharacter.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="n">AMyCharacter</span><span class="o">::</span><span class="n">AMyCharacter</span><span class="p">(</span><span class="k">const</span> <span class="n">FObjectInitializer</span><span class="o">&amp;</span> <span class="n">ObjectInitializer</span><span class="p">)</span>
	<span class="o">:</span><span class="n">Super</span><span class="p">(</span><span class="n">ObjectInitializer</span><span class="p">.</span><span class="n">SetDefaultSubobjectClass</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ACharacter</span><span class="o">::</span><span class="n">CharacterMovementComponentName</span><span class="p">))</span>
<span class="p">{</span>
	<span class="c1">//Do normal stuff in constructor...</span>
<span class="p">}</span>
</pre></div>
<h2><span class="mw-headline" id="Implementing_Movement_Abilities">Implementing Movement Abilities</span></h2>
<h3><span class="mw-headline" id="Sprint">Sprint</span></h3>
<p>Sprint is an example of an ability that can be implemented quite easily using just the compressed flags. To start with, we'll implement a basic unlimited sprint ability. We'll gradually improve it as we go along.
</p>
<h4><span class="mw-headline" id="Unlimited_Sprint">Unlimited Sprint</span></h4>
<p>The first thing to do is add the input events to the character class.
</p><p><i>MyCharacter.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="n">AMyCharacter</span><span class="o">::</span><span class="n">SetupPlayerInputComponent</span><span class="p">(</span><span class="k">class</span> <span class="nc">UInputComponent</span><span class="o">*</span> <span class="n">InputComponent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">check</span><span class="p">(</span><span class="n">InputComponent</span><span class="p">);</span>

	<span class="n">InputComponent</span><span class="o">-&gt;</span><span class="n">BindAction</span><span class="p">(</span><span class="s">&quot;Sprint&quot;</span><span class="p">,</span> <span class="n">IE_Pressed</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">AMyCharacter</span><span class="o">::</span><span class="n">StartSprinting</span><span class="p">);</span>
	<span class="n">InputComponent</span><span class="o">-&gt;</span><span class="n">BindAction</span><span class="p">(</span><span class="s">&quot;Sprint&quot;</span><span class="p">,</span> <span class="n">IE_Released</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">AMyCharacter</span><span class="o">::</span><span class="n">StopSprinting</span><span class="p">);</span>

	<span class="c1">//Other input bindings...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AMyCharacter</span><span class="o">::</span><span class="n">StartSprinting</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">MoveComp</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MoveComp</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">MoveComp</span><span class="o">-&gt;</span><span class="n">SetSprinting</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AMyCharacter</span><span class="o">::</span><span class="n">StopSprinting</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">MoveComp</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MoveComp</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">MoveComp</span><span class="o">-&gt;</span><span class="n">SetSprinting</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>The character movement component will need to have the SetSprinting method, and also a few properties. Add the following properties and methods to <i>MyCharacterMovement.h</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span> <span class="o">=</span> <span class="s">&quot;Sprint&quot;</span><span class="p">)</span>
<span class="kt">float</span> <span class="n">SprintSpeedMultiplier</span><span class="p">;</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span> <span class="o">=</span> <span class="s">&quot;Sprint&quot;</span><span class="p">)</span>
<span class="kt">float</span> <span class="n">SprintAccelerationMultiplier</span><span class="p">;</span>

<span class="c1">///@brief Activate or deactivate sprint.</span>
<span class="kt">void</span> <span class="nf">SetSprinting</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bSprinting</span><span class="p">);</span>

<span class="c1">///@brief Flag for activating sprint.</span>
<span class="n">uint8</span> <span class="nl">bWantsToSprint</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">///@brief Override maximum speed during sprint.</span>
<span class="k">virtual</span> <span class="kt">float</span> <span class="nf">GetMaxSpeed</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="c1">///@brief Override maximum acceleration for sprint.</span>
<span class="k">virtual</span> <span class="kt">float</span> <span class="nf">GetMaxAcceleration</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
</pre></div>
<p>SetSprinting will be called to activate the sprint ability, and should need no explanation. GetMaxSpeed and GetMaxAcceleration use the sprint flag to determine whether or not to apply the speed and acceleration multipliers. This is all you need for a single player game, but try to run this in a networked game you'll quickly discover it doesn't work. The client can't sprint because the server doesn't know it's trying to, so it keeps getting corrected back to the normal walking speed.
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">SetSprinting</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bSprinting</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bWantsToSprint</span> <span class="o">=</span> <span class="n">bSprinting</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">GetMaxSpeed</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">MaxSpeed</span> <span class="o">=</span> <span class="n">Super</span><span class="o">::</span><span class="n">GetMaxSpeed</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bWantsToSprint</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">MaxSpeed</span> <span class="o">*=</span> <span class="n">SprintSpeedMultiplier</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">MaxSpeed</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">GetMaxAcceleration</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">MaxAccel</span> <span class="o">=</span> <span class="n">Super</span><span class="o">::</span><span class="n">GetMaxAcceleration</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bWantsToSprint</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">MaxAccel</span> <span class="o">*=</span> <span class="n">SprintAccelerationMultiplier</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">MaxAccel</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>To make this replicate to the server and work with the prediction system we'll finally need to use the saved move class we inherited from earlier. We need to add a flag corresponding to the character movement component's sprint flag. This flag is used to re-trigger the ability later if a network correction forces us to resimulate the move. 
</p><p><i>MyCharacterMovement.h</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="k">class</span> <span class="nc">FSavedMove_MyMovement</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FSavedMove_Character</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

	<span class="k">typedef</span> <span class="n">FSavedMove_Character</span> <span class="n">Super</span><span class="p">;</span>

	<span class="c1">///@brief Resets all saved variables.</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Clear</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

	<span class="c1">///@brief Store input commands in the compressed flags.</span>
	<span class="k">virtual</span> <span class="n">uint8</span> <span class="nf">GetCompressedFlags</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

	<span class="c1">///@brief This is used to check whether or not two moves can be combined into one.</span>
	<span class="c1">///Basically you just check to make sure that the saved variables are the same.</span>
	<span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">CanCombineWith</span><span class="p">(</span><span class="k">const</span> <span class="n">FSavedMovePtr</span><span class="o">&amp;</span> <span class="n">NewMove</span><span class="p">,</span> <span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">MaxDelta</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

	<span class="c1">///@brief Sets up the move before sending it to the server. </span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">SetMoveFor</span><span class="p">(</span><span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">FVector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="k">class</span> <span class="nc">FNetworkPredictionData_Client_Character</span> <span class="o">&amp;</span> <span class="n">ClientData</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
	<span class="c1">///@brief Sets variables on character movement component before making a predictive correction.</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PrepMoveFor</span><span class="p">(</span><span class="k">class</span> <span class="nc">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

	<span class="n">uint8</span> <span class="nl">bSavedWantsToSprint</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>The character movement component will create these saved moves and fill them with data needed to replay moves on the server. The implementation of the saved move is pretty much just responsible for copying the variables needed to make the movement calculations back and forth between the saved move and the character movement component. Also, the SprintSpeedMultiplier and SprintAccelerationMultiplier should be given sensible default values in the constructor (2.0f should work fine).
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">UpdateFromCompressedFlags</span><span class="p">(</span><span class="n">uint8</span> <span class="n">Flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">UpdateFromCompressedFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">);</span>

	<span class="c1">//The Flags parameter contains the compressed input flags that are stored in the saved move.</span>
	<span class="c1">//UpdateFromCompressed flags simply copies the flags from the saved move into the movement component.</span>
	<span class="c1">//It basically just resets the movement component to the state when the move was made so it can simulate from there.</span>
	<span class="n">bWantsToSprint</span> <span class="o">=</span> <span class="p">(</span><span class="n">Flags</span><span class="o">&amp;</span><span class="n">FSavedMove_Character</span><span class="o">::</span><span class="n">FLAG_Custom_0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">FVector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="k">class</span> <span class="nc">FNetworkPredictionData_Client_Character</span><span class="o">&amp;</span> <span class="n">ClientData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">Character</span><span class="p">,</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="n">ClientData</span><span class="p">);</span>

	<span class="n">UExtendedCharacterMovement</span><span class="o">*</span> <span class="n">CharMov</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UExtendedCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Character</span><span class="o">-&gt;</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CharMov</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//This is literally just the exact opposite of UpdateFromCompressed flags. We&#39;re taking the input</span>
		<span class="c1">//from the player and storing it in the saved move.</span>
		<span class="n">bSavedWantsToSprint</span> <span class="o">=</span> <span class="n">CharMov</span><span class="o">-&gt;</span><span class="n">bWantsToSprint</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">Clear</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">Clear</span><span class="p">();</span>

	<span class="c1">//Clear variables back to their default values.</span>
	<span class="n">bSavedWantsToSprint</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//This is where we compress the flags saved in SetMoveFor. We&#39;re basically just ORing a bunch of them together.</span>
<span class="n">uint8</span> <span class="n">FSavedMove_ExtendedMovement</span><span class="o">::</span><span class="n">GetCompressedFlags</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="n">uint8</span> <span class="n">Result</span> <span class="o">=</span> <span class="n">Super</span><span class="o">::</span><span class="n">GetCompressedFlags</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bSavedWantsToSprint</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Result</span> <span class="o">|=</span> <span class="n">FLAG_Custom_0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">FSavedMove_ExtendedMovement</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="k">const</span> <span class="n">FSavedMovePtr</span><span class="o">&amp;</span> <span class="n">NewMove</span><span class="p">,</span> <span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">MaxDelta</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="c1">//This pretty much just tells the engine if it can optimize by combining saved moves. There doesn&#39;t appear to be</span>
	<span class="c1">//any problem with leaving it out, but it seems that it&#39;s good practice to implement this anyways.</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bSavedWantsToSprint</span> <span class="o">!=</span> <span class="p">((</span><span class="n">FSavedMove_ExtendedMovement</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NewMove</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bSavedWantsToSprint</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">Super</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="n">NewMove</span><span class="p">,</span> <span class="n">Character</span><span class="p">,</span> <span class="n">MaxDelta</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>At this point you should have a basic sprint ability that can be triggered from either the client, or server. However, the sprint ability right now isn't very customizable. The player can sprint sideways and backwards just as easily as forwards, and can also sprint forever with no breaks between.
</p>
<h4><span class="mw-headline" id="Only_Sprint_Forward">Only Sprint Forward</span></h4>
<p>Disclaimer: This is only my current implementation. If I come up with a better way then I'll update this tutorial.
</p><p>There are a couple ways to prevent the player from sprinting sideways and backwards. One way would be to store the forward key state in the compressed flags just like we did with bWantsToSprint. This is fairly easy to do, but it uses up a flag that could be used for other abilities. It's actually possible to prevent the player from sprinting in other directions without sending any additional data.
</p><p>Since inputs are handled by the saved move, as long as our calculations only rely on things that are replicated (velocity and rotation in this example), then we can make calculations based on them. Start by adding a method to check that we're moving forward.
</p><p><i>MyCharacterMovement.h</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">///@return Whether or not the character is currently moving in a forward direction.</span>
<span class="kt">bool</span> <span class="nf">IsMovingForward</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
<p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">bool</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">IsMovingForward</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PawnOwner</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">FVector</span> <span class="n">Forward</span> <span class="o">=</span> <span class="n">PawnOwner</span><span class="o">-&gt;</span><span class="n">GetActorForwardVector</span><span class="p">();</span>
	<span class="n">FVector</span> <span class="n">MoveDirection</span> <span class="o">=</span> <span class="n">Velocity</span><span class="p">.</span><span class="n">GetSafeNormal</span><span class="p">();</span>

	<span class="c1">//Ignore vertical movement</span>
	<span class="n">Forward</span><span class="p">.</span><span class="n">Z</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
	<span class="n">MoveDirection</span><span class="p">.</span><span class="n">Z</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>

	<span class="kt">float</span> <span class="n">VelocityDot</span> <span class="o">=</span> <span class="n">FVector</span><span class="o">::</span><span class="n">DotProduct</span><span class="p">(</span><span class="n">Forward</span><span class="p">,</span> <span class="n">MoveDirection</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">VelocityDot</span> <span class="o">&gt;</span> <span class="mf">0.7f</span><span class="p">;</span><span class="c1">//Check to make sure difference between headings is not too great.</span>
<span class="p">}</span>
</pre></div>
<p>Then we simply check to make sure we're moving forward before applying the sprint speed boost in GetMaxSpeed and GetMaxAcceleration
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">float</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">GetMaxSpeed</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">MaxSpeed</span> <span class="o">=</span> <span class="n">Super</span><span class="o">::</span><span class="n">GetMaxSpeed</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bWantsToSprint</span> <span class="o">&amp;&amp;</span> <span class="n">IsMovingForward</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">MaxSpeed</span> <span class="o">*=</span> <span class="n">SprintSpeedMultiplier</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">MaxSpeed</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">GetMaxAcceleration</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">MaxAccel</span> <span class="o">=</span> <span class="n">Super</span><span class="o">::</span><span class="n">GetMaxAcceleration</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bWantsToSprint</span> <span class="o">&amp;&amp;</span> <span class="n">IsMovingForward</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">MaxAccel</span> <span class="o">*=</span> <span class="n">SprintAccelerationMultiplier</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">MaxAccel</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h3><span class="mw-headline" id="Boost_Dodge">Boost Dodge</span></h3>
<p>A popular feature lately in FPS games is to have boost dodges/thruster packs basically your character quickly boosts horizontally to avoid damage, close the distance for a melee, make a long jump, or whatever else the player wants to try and use it for. Two prime examples of recent games with this ability being Halo 5 and Call of Duty: Advanced Warfare. The boost dodge ability is one example of an ability that can benefit from sending extra data alongside the typical activation flags. In Unreal Tournament 4 the ability is implemented using four flags: one for each boost direction, but in this implementation we'll be sending along the character's movement vector to the server, since we can reuse it for other abilities as well.
</p><p>To start with we'll deal with how to send additional input data to use in prediction. First add a variable to store it in the character movement component, then add the corresponding saved direction vector to the FSavedMove_MyMovement class. We'll also need to override the OnMovementUpdated method. The ability activation flag is handled just like bWantsToSprint. Don't forget to give DodgeStrength and GroundDodgeStrengthMultiplier some sane default values in the constructor.
</p><p><i>MyCharacterMovement.h</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">//Inside UMyCharacterMovement class...</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span> <span class="o">=</span> <span class="s">&quot;Dodge&quot;</span><span class="p">)</span>
<span class="kt">float</span> <span class="n">DodgeStrength</span><span class="p">;</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span> <span class="o">=</span> <span class="s">&quot;Dodge&quot;</span><span class="p">)</span>
<span class="kt">float</span> <span class="n">GroundDodgeStrengthMultiplier</span><span class="p">;</span>

<span class="n">UFUNCTION</span><span class="p">(</span><span class="n">Unreliable</span><span class="p">,</span> <span class="n">Server</span><span class="p">,</span> <span class="n">WithValidation</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">ServerSetMoveDirection</span><span class="p">(</span><span class="k">const</span> <span class="n">FVector</span><span class="o">&amp;</span> <span class="n">MoveDir</span><span class="p">);</span>

<span class="c1">///@brief Triggers the dodge action.</span>
<span class="kt">void</span> <span class="nf">DoDodge</span><span class="p">();</span>

<span class="c1">///@brief Event triggered at the end of a movement update</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnMovementUpdated</span><span class="p">(</span><span class="kt">float</span> <span class="n">DeltaSeconds</span><span class="p">,</span> <span class="k">const</span> <span class="n">FVector</span> <span class="o">&amp;</span> <span class="n">OldLocation</span><span class="p">,</span> <span class="k">const</span> <span class="n">FVector</span> <span class="o">&amp;</span> <span class="n">OldVelocity</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="n">FVector</span> <span class="n">MoveDirection</span><span class="p">;</span>
<span class="n">uint8</span> <span class="nl">bWantsToDodge</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">//Inside FSavedMove_MyMovement class...</span>
<span class="n">FVector</span> <span class="n">SavedMoveDirection</span><span class="p">;</span>
<span class="n">uint8</span> <span class="nl">bSavedWantsToDodge</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">///@brief This is used to copy state from the saved move to the character movement component.</span>
<span class="c1">///This is ONLY used for predictive corrections, the actual data must be sent through RPC.</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PrepMoveFor</span><span class="p">(</span><span class="k">class</span> <span class="nc">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</pre></div>
<p>For sending extra client inputs to the server, we'll need to use RPC functions in place of the compressed flags. A convenient place to send the inputs is in the beginning of the OnMovementUpdated method.
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">bool</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">ServerSetMoveDirection_Validate</span><span class="p">(</span><span class="k">const</span> <span class="n">FVector</span><span class="o">&amp;</span> <span class="n">MoveDir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">ServerSetMoveDirection_Implementation</span><span class="p">(</span><span class="k">const</span> <span class="n">FVector</span><span class="o">&amp;</span> <span class="n">MoveDir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MoveDirection</span> <span class="o">=</span> <span class="n">DodgeDir</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">OnMovementUpdated</span><span class="p">(</span><span class="kt">float</span> <span class="n">DeltaSeconds</span><span class="p">,</span> <span class="k">const</span> <span class="n">FVector</span><span class="o">&amp;</span> <span class="n">OldLocation</span><span class="p">,</span> <span class="k">const</span> <span class="n">FVector</span><span class="o">&amp;</span> <span class="n">OldVelocity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">OnMovementUpdated</span><span class="p">(</span><span class="n">DeltaSeconds</span><span class="p">,</span> <span class="n">OldLocation</span><span class="p">,</span> <span class="n">OldVelocity</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CharacterOwner</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//Store movement vector</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PawnOwner</span><span class="o">-&gt;</span><span class="n">IsLocallyControlled</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">MoveDirection</span> <span class="o">=</span> <span class="n">PawnOwner</span><span class="o">-&gt;</span><span class="n">GetLastMovementInputVector</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="c1">//Send movement vector to server</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PawnOwner</span><span class="o">-&gt;</span><span class="n">Role</span> <span class="o">&lt;</span> <span class="n">ROLE_Authority</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ServerSetMoveDirection</span><span class="p">(</span><span class="n">MoveDirection</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>The input will also need to be added to the saved moves. The implementation is very similar to adding an input flag to the saved moves, but does not involve compressed flag methods. The only difference is that PrepMoveFor needs to be implemented to allow for client corrections to be made.
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">FVector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="k">class</span> <span class="nc">FNetworkPredictionData_Client_Character</span><span class="o">&amp;</span> <span class="n">ClientData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">Character</span><span class="p">,</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="n">ClientData</span><span class="p">);</span>

	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">CharMov</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Character</span><span class="o">-&gt;</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CharMov</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//This is literally just the exact opposite of UpdateFromCompressed flags. We&#39;re taking the input</span>
		<span class="c1">//from the player and storing it in the saved move.</span>
		<span class="n">bSavedWantsToSprint</span> <span class="o">=</span> <span class="n">CharMov</span><span class="o">-&gt;</span><span class="n">bWantsToSprint</span><span class="p">;</span>

		<span class="c1">//Again, just taking the player movement component&#39;s state and storing it for later it in the saved move.</span>
		<span class="n">SavedMoveDirection</span> <span class="o">=</span> <span class="n">CharMov</span><span class="o">-&gt;</span><span class="n">MoveDirection</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">Clear</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">Clear</span><span class="p">();</span>

	<span class="c1">//Clear variables back to their default values.</span>
	<span class="n">bSavedWantsToSprint</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">SavedMoveDirection</span> <span class="o">=</span> <span class="n">FVector</span><span class="o">::</span><span class="n">ZeroVector</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="k">const</span> <span class="n">FSavedMovePtr</span><span class="o">&amp;</span> <span class="n">NewMove</span><span class="p">,</span> <span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">MaxDelta</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="c1">//This pretty much just tells the engine if it can optimize by combining saved moves. There doesn&#39;t appear to be</span>
	<span class="c1">//any problem with leaving it out, but it seems that it&#39;s good practice to implement this anyways.</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bSavedWantsToSprint</span> <span class="o">!=</span> <span class="p">((</span><span class="n">FSavedMove_ExtendedMovement</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NewMove</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bSavedWantsToSprint</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SavedMoveDirection</span> <span class="o">!=</span> <span class="p">((</span><span class="n">FSavedMove_ExtendedMovement</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NewMove</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SavedMoveDirection</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">Super</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="n">NewMove</span><span class="p">,</span> <span class="n">Character</span><span class="p">,</span> <span class="n">MaxDelta</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">PrepMoveFor</span><span class="p">(</span><span class="k">class</span> <span class="nc">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">PrepMoveFor</span><span class="p">(</span><span class="n">Character</span><span class="p">);</span>

	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">CharMov</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Character</span><span class="o">-&gt;</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CharMov</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//This is just the exact opposite of SetMoveFor. It copies the state from the saved move to the movement</span>
		<span class="c1">//component before a correction is made to a client.</span>
		<span class="n">CharMov</span><span class="o">-&gt;</span><span class="n">MoveDirection</span> <span class="o">=</span> <span class="n">SavedMoveDirection</span><span class="p">;</span>
		
		<span class="c1">//Don&#39;t update flags here. They&#39;re automatically setup before corrections using the compressed flag methods.</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Now we have all the data needed in order to implement the actual ability in OnMovementUpdated. We'll also need to implement the method to trigger the ability and hook it up to the character's input component. For the sake of brevity, and my own sanity, it's assumed that you can figure out how to hook up the DoDodge method to the input component by now if you've already made it this far, so that bit of code has been omitted.
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">OnMovementUpdated</span><span class="p">(</span><span class="kt">float</span> <span class="n">DeltaSeconds</span><span class="p">,</span> <span class="k">const</span> <span class="n">FVector</span><span class="o">&amp;</span> <span class="n">OldLocation</span><span class="p">,</span> <span class="k">const</span> <span class="n">FVector</span><span class="o">&amp;</span> <span class="n">OldVelocity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">OnMovementUpdated</span><span class="p">(</span><span class="n">DeltaSeconds</span><span class="p">,</span> <span class="n">OldLocation</span><span class="p">,</span> <span class="n">OldVelocity</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CharacterOwner</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//Store movement vector</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PawnOwner</span><span class="o">-&gt;</span><span class="n">IsLocallyControlled</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">MoveDirection</span> <span class="o">=</span> <span class="n">PawnOwner</span><span class="o">-&gt;</span><span class="n">GetLastMovementInputVector</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="c1">//Send movement vector to server</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PawnOwner</span><span class="o">-&gt;</span><span class="n">Role</span> <span class="o">&lt;</span> <span class="n">ROLE_Authority</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ServerSetMoveDirection</span><span class="p">(</span><span class="n">MoveDirection</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//Update dodge movement</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bWantsToDodge</span><span class="p">)</span>
	<span class="p">{</span>		
		<span class="n">MoveDirection</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
		<span class="n">FVector</span> <span class="n">DodgeVel</span> <span class="o">=</span> <span class="n">MoveDirection</span><span class="o">*</span><span class="n">DodgeStrength</span><span class="p">;</span>
		<span class="n">DodgeVel</span><span class="p">.</span><span class="n">Z</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IsMovingOnGround</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="n">DodgeVel</span> <span class="o">*=</span> <span class="n">GroundDodgeStrengthMultiplier</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">Launch</span><span class="p">(</span><span class="n">DodgeVel</span><span class="p">);</span>

		<span class="n">bWantsToDodge</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">DoDodge</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">bWantsToDodge</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Now you should be able to test the character movement and boost around using whatever key you've assigned boost to. To keep things simple, this is just a basic boost implementation. You could get more advanced and average the velocities in OnMovementUpdated so that you boost faster when going forward, or use all sorts of other math to make things more interesting.
</p>
<h3><span class="mw-headline" id="Double_Jump">Double Jump</span></h3>
<p>A simple double jump is actually quite easy to implement. The first thing is to override the CanJumpInternal_Implementation method in the character class so that we can actually trigger the extra jump.
</p><p><i>MyCharacter.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">bool</span> <span class="n">AMyCharacter</span><span class="o">::</span><span class="n">CanJumpInternal_Implementation</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">bCanJump</span> <span class="o">=</span> <span class="n">Super</span><span class="o">::</span><span class="n">CanJumpInternal_Implementation</span><span class="p">();</span>

	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">MyMovementComp</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bCanJump</span> <span class="o">&amp;&amp;</span> <span class="n">MyMovementComp</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">bCanJump</span> <span class="o">=</span> <span class="n">MyMovementComp</span><span class="o">-&gt;</span><span class="n">CanJump</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bCanJump</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>It's much more convenient to check for double jumping capability inside the character movement component, so we'll just call into a CanJump method we'll add to it. Additionally, we'll want to override a couple methods, and add a couple properties. We'll also need to add a member to the saved move for corrections to work.
</p><p><i>MyCharacterMovement.h</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">//Inside UMyCharacterMovement...</span>

<span class="c1">///@brief Override DoJump to trigger the extra jumps.</span>
<span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">DoJump</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bReplayingMoves</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="c1">///@return Whether or not the character can currently jump.</span>
<span class="kt">bool</span> <span class="nf">CanJump</span><span class="p">();</span>
<span class="c1">///@brief This is called whenever the character lands on the ground, and will be used to reset the jump counter.</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">ProcessLanded</span><span class="p">(</span><span class="k">const</span> <span class="n">FHitResult</span><span class="o">&amp;</span> <span class="n">Hit</span><span class="p">,</span> <span class="kt">float</span> <span class="n">remainingTime</span><span class="p">,</span> <span class="n">int32</span> <span class="n">Iterations</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">Category</span> <span class="o">=</span> <span class="s">&quot;Multijump&quot;</span><span class="p">,</span> <span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">BlueprintReadWrite</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">DisplayName</span> <span class="o">=</span> <span class="s">&quot;Max Multijump Count&quot;</span><span class="p">))</span>
<span class="n">int32</span> <span class="n">MaxJumpCount</span><span class="p">;</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">Category</span> <span class="o">=</span> <span class="s">&quot;Multijump&quot;</span><span class="p">,</span> <span class="n">BlueprintReadWrite</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">DisplayName</span> <span class="o">=</span> <span class="s">&quot;Current jump count&quot;</span><span class="p">))</span>
<span class="n">int32</span> <span class="n">JumpCount</span><span class="p">;</span>

<span class="c1">//Inside FSavedMove_MyMovement...</span>
<span class="n">int32</span> <span class="n">SavedJumpCount</span><span class="p">;</span>
</pre></div>
<p>Okay, I lied. It's not necessarily a double jump, because you can set the MaxJumpCount property higher than 2 to let your character jump as many times as you want. It turns out it's easier to implement this way though, so you basically get extra functionality for free.
</p><p>First of all just get all the saved move stuff out of the way. Not much special here, just the same as before. The only difference being we don't have to bother sending the JumpCount through an RPC, because it just gets incremented on both the client and server whenever a jump is triggered.
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">Clear</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">Clear</span><span class="p">();</span>

	<span class="c1">//Omitted variables from previous abilities...</span>

	<span class="n">SavedJumpCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="k">const</span> <span class="n">FSavedMovePtr</span><span class="o">&amp;</span> <span class="n">NewMove</span><span class="p">,</span> <span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">MaxDelta</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="c1">//Omitted variables from previous abilities...</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SavedJumpCount</span> <span class="o">!=</span> <span class="p">((</span><span class="n">FSavedMove_MyMovement</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NewMove</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SavedJumpCount</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">Super</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="n">NewMove</span><span class="p">,</span> <span class="n">Character</span><span class="p">,</span> <span class="n">MaxDelta</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">FVector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="k">class</span> <span class="nc">FNetworkPredictionData_Client_Character</span> <span class="o">&amp;</span> <span class="n">ClientData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">Character</span><span class="p">,</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="n">ClientData</span><span class="p">);</span>

	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">CharMov</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Character</span><span class="o">-&gt;</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CharMov</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//Omitted variables from previous abilities...</span>

		<span class="n">SavedJumpCount</span> <span class="o">=</span> <span class="n">CharMov</span><span class="o">-&gt;</span><span class="n">JumpCount</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">PrepMoveFor</span><span class="p">(</span><span class="k">class</span> <span class="nc">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">PrepMoveFor</span><span class="p">(</span><span class="n">Character</span><span class="p">);</span>

	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">CharMov</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Character</span><span class="o">-&gt;</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CharMov</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//Omitted variables from previous abilities...</span>

		<span class="n">CharMov</span><span class="o">-&gt;</span><span class="n">JumpCount</span> <span class="o">=</span> <span class="n">SavedJumpCount</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Now comes the actual extra jump implementation. To let the player even trigger the jump, the CanJump method we call into from the character class needs to be implemented. It's pretty self explanatory.
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">bool</span> <span class="n">UExtendedCharacterMovement</span><span class="o">::</span><span class="n">CanJump</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">IsMovingOnGround</span><span class="p">()</span> <span class="o">||</span> <span class="n">JumpCount</span> <span class="o">&lt;</span> <span class="n">MaxJumpCount</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">CanEverJump</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<p>Now all that remains is to increment the jump count whenever an extra jump is triggered, and reset it on landing. The character movement component has a DoJump method for incrementing the counter, and a convenient ProcessLanded method we can override to reset the counter. 
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">bool</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">DoJump</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bReplayingMoves</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Super</span><span class="o">::</span><span class="n">DoJump</span><span class="p">(</span><span class="n">bReplayingMoves</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">JumpCount</span><span class="o">++</span><span class="p">;</span>

		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">ProcessLanded</span><span class="p">(</span><span class="k">const</span> <span class="n">FHitResult</span><span class="o">&amp;</span> <span class="n">Hit</span><span class="p">,</span> <span class="kt">float</span> <span class="n">remainingTime</span><span class="p">,</span> <span class="n">int32</span> <span class="n">Iterations</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">JumpCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">Super</span><span class="o">::</span><span class="n">ProcessLanded</span><span class="p">(</span><span class="n">Hit</span><span class="p">,</span> <span class="n">remainingTime</span><span class="p">,</span> <span class="n">Iterations</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>The double jump will work now if all you want to do is add an extra jump. The only problem is you can't really change directions while jumping. The good news is, we sent the movement vector earlier so that we could boost in different directions, so we can just reuse that here to make whatever velocity calculations we want to.
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">bool</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">DoJump</span><span class="p">(</span><span class="kt">bool</span> <span class="n">bReplayingMoves</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Super</span><span class="o">::</span><span class="n">DoJump</span><span class="p">(</span><span class="n">bReplayingMoves</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">JumpCount</span><span class="o">++</span><span class="p">;</span>

		<span class="c1">//Adjust midair velocity using the input direction</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">JumpCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">//Calculate lateral speed to use in adjusting trajectory in midair</span>
			<span class="n">FVector</span> <span class="n">LateralVelocity</span> <span class="o">=</span> <span class="n">Velocity</span><span class="p">;</span>
			<span class="n">LateralVelocity</span><span class="p">.</span><span class="n">Z</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span><span class="c1">//Don&#39;t care about vertical velocity</span>
			<span class="kt">float</span> <span class="n">LateralSpeed</span> <span class="o">=</span> <span class="n">LateralVelocity</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>

			<span class="c1">//Average the actual velocity with the target velocity</span>
			<span class="n">FVector</span> <span class="n">NewVelocity</span> <span class="o">=</span> <span class="n">MoveDirection</span><span class="o">*</span><span class="n">LateralSpeed</span><span class="p">;</span>
			<span class="n">NewVelocity</span><span class="p">.</span><span class="n">Z</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
			<span class="n">NewVelocity</span> <span class="o">+=</span> <span class="n">LateralVelocity</span><span class="p">;</span>
			<span class="n">NewVelocity</span> <span class="o">*=</span> <span class="mf">0.5f</span><span class="p">;</span>

			<span class="n">Velocity</span> <span class="o">=</span> <span class="n">NewVelocity</span><span class="p">;</span>
			<span class="n">Velocity</span><span class="p">.</span><span class="n">Z</span> <span class="o">=</span> <span class="n">JumpZVelocity</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Now jumping while holding in a different direction will cause the character to change directions mid jump.
</p>
<h2><span class="mw-headline" id="Cooldown_Timers">Cooldown Timers</span></h2>
<p>The last example for character movement is cooldown timers on abilities. The boost dodge ability will be used to demonstrate how to implement a simple cooldown timer. The same concept applies to sprint energy and other timer/energy type effects as well.
</p><p>Timers are just calculated on both the client and the server independently, because they don't really need to match up perfectly since the server is authoritative. The only reason they need to be calculated on the client too is so that players don't try to spam the boost button and see their character getting corrected back to its original position. If you have a timer that really needs to be synchronized, then you could probably set it to be replicated, but in the interest of not wasting bandwidth the boost timer won't be replicated.
</p><p><i>MyCharacterMovement.h</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="c1">//Inside UMyCharacterMovement class...</span>

<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Category</span> <span class="o">=</span> <span class="s">&quot;Dodge&quot;</span><span class="p">)</span>
<span class="kt">float</span> <span class="n">DodgeCooldown</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">DodgeCooldownTimer</span><span class="p">;</span>

<span class="c1">//Inside FSavedMove_MyMovement class...</span>
<span class="kt">float</span> <span class="n">SavedDodgeCooldownTimer</span><span class="p">;</span>
</pre></div>
<p>DodgeCooldown should be initialized to something like 2.0f or whatever you want the cooldown time to be. DodgeCooldownTimer is what will actually be doing the timing, so set it to 0.0f in the constructor. We'll use OnMovementUpdated to update our timers.
</p><p><i>MyCharacterMovement.cpp</i>
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="n">UMyCharacterMovement</span><span class="o">::</span><span class="n">OnMovementUpdated</span><span class="p">(</span><span class="kt">float</span> <span class="n">DeltaSeconds</span><span class="p">,</span> <span class="k">const</span> <span class="n">FVector</span><span class="o">&amp;</span> <span class="n">OldLocation</span><span class="p">,</span> <span class="k">const</span> <span class="n">FVector</span><span class="o">&amp;</span> <span class="n">OldVelocity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//...</span>

	<span class="c1">//Update dodge movement</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bWantsToDodge</span> <span class="o">&amp;&amp;</span> <span class="n">DodgeCooldownTimer</span> <span class="o">&lt;=</span> <span class="mf">0.0f</span><span class="p">)</span>
	<span class="p">{</span>		
		<span class="n">MoveDirection</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
		<span class="n">FVector</span> <span class="n">DodgeVel</span> <span class="o">=</span> <span class="n">MoveDirection</span><span class="o">*</span><span class="n">DodgeStrength</span><span class="p">;</span>
		<span class="n">DodgeVel</span><span class="p">.</span><span class="n">Z</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IsMovingOnGround</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="n">DodgeVel</span> <span class="o">*=</span> <span class="n">GroundDodgeStrengthMultiplier</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">Launch</span><span class="p">(</span><span class="n">DodgeVel</span><span class="p">);</span>

		<span class="n">bWantsToDodge</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="c1">//Reset cooldown timer</span>
		<span class="n">DodgeCooldownTimer</span> <span class="o">=</span> <span class="n">DodgeCooldown</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//Update cooldown timers</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DodgeCooldownTimer</span> <span class="o">&gt;</span> <span class="mf">0.0f</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">DodgeCooldownTimer</span> <span class="o">-=</span> <span class="n">DeltaSeconds</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
<p>We pretty much just update and check against the timers all in the OnMovementUpdated method. After a while this can get kind of messy, so in a larger project with lots of movement abilities it can be beneficial to refactor things a bit and maybe split stuff up into more methods, but for the sake of this example this will work fine.
</p><p>Finally, just do the usual with the saved moves.
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span></span><span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">Clear</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">Clear</span><span class="p">();</span>
 
	<span class="c1">//Omitted other variables...</span>
 
	<span class="n">SavedDodgeCooldownTimer</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">bool</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="k">const</span> <span class="n">FSavedMovePtr</span><span class="o">&amp;</span> <span class="n">NewMove</span><span class="p">,</span> <span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">MaxDelta</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="c1">//Omitted other variables...</span>
 
	<span class="k">if</span> <span class="p">(</span><span class="n">SavedDodgeCooldownTimer</span><span class="o">!=</span> <span class="p">((</span><span class="n">FSavedMove_MyMovement</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NewMove</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SavedDodgeCooldownTimer</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
 
	<span class="k">return</span> <span class="n">Super</span><span class="o">::</span><span class="n">CanCombineWith</span><span class="p">(</span><span class="n">NewMove</span><span class="p">,</span> <span class="n">Character</span><span class="p">,</span> <span class="n">MaxDelta</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">,</span> <span class="kt">float</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">FVector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="k">class</span> <span class="nc">FNetworkPredictionData_Client_Character</span> <span class="o">&amp;</span> <span class="n">ClientData</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">SetMoveFor</span><span class="p">(</span><span class="n">Character</span><span class="p">,</span> <span class="n">InDeltaTime</span><span class="p">,</span> <span class="n">NewAccel</span><span class="p">,</span> <span class="n">ClientData</span><span class="p">);</span>
 
	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">CharMov</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Character</span><span class="o">-&gt;</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CharMov</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//Omitted other variables...</span>
 
		<span class="n">SavedDodgeCooldownTimer</span> <span class="o">=</span> <span class="n">CharMov</span><span class="o">-&gt;</span><span class="n">DodgeCooldownTimer</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">FSavedMove_MyMovement</span><span class="o">::</span><span class="n">PrepMoveFor</span><span class="p">(</span><span class="k">class</span> <span class="nc">ACharacter</span><span class="o">*</span> <span class="n">Character</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">PrepMoveFor</span><span class="p">(</span><span class="n">Character</span><span class="p">);</span>
 
	<span class="n">UMyCharacterMovement</span><span class="o">*</span> <span class="n">CharMov</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">UMyCharacterMovement</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Character</span><span class="o">-&gt;</span><span class="n">GetCharacterMovement</span><span class="p">());</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CharMov</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//Omitted other variables...</span>
 
		<span class="n">CharMov</span><span class="o">-&gt;</span><span class="n">DodgeCooldownTimer</span> <span class="o">=</span> <span class="n">SavedDodgeCooldownTimer</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2><span class="mw-headline" id="Conclusion">Conclusion</span></h2>
<p>Most movement abilities should be easy to implement in quite a similar fashion. A jetpack would just need to use the compressed flags to set some sort of bWantsToJetpack on the movement component, then just use OnMovementUpdated to adjust the velocity.
</p><p>If you find any errors, or have any questions or suggestions about this tutorial then just drop them in the <a rel="nofollow" class="external text" href="https://forums.unrealengine.com/showthread.php?79646-Wiki-Authoritative-Networked-Character-Movement-Tutorial&amp;p=351317#post351317">forum thread</a> and I'll try to update accordingly.
</p>
<h2><span class="mw-headline" id="Other_Resources">Other Resources</span></h2>
<p>This section just includes links to various useful resources relating to the character movement component. I'll be updating this whenever I find more.
</p><p><a href="index5364.html?title=Custom_Character_Movement_Component" title="Custom Character Movement Component">Custom Character Movement Component</a>
</p><p><a rel="nofollow" class="external text" href="https://docs.unrealengine.com/latest/INT/Gameplay/Networking/CharacterMovementComponent/index.html">Character Movement Component docs</a>
</p><p><a rel="nofollow" class="external text" href="http://error454.com/2015/03/20/ue4/movement/replication/">Error545's Character Movement Replication in UE4 blog post</a>
</p><p><a rel="nofollow" class="external text" href="https://forums.unrealengine.com/showthread.php?5047-How-to-add-a-movement-type-inherited-from-Walking-Like-Covering">Custom Movement Modes</a>
</p><p><a rel="nofollow" class="external text" href="https://github.com/EpicGames/UnrealTournament/blob/clean-master/UnrealTournament/Source/UnrealTournament/Public/UTCharacterMovement.h">UTCharacterMovement.h</a>
</p><p><a rel="nofollow" class="external text" href="https://github.com/EpicGames/UnrealTournament/blob/clean-master/UnrealTournament/Source/UnrealTournament/Private/UTCharacterMovement.cpp">UTCharacterMovement.cpp</a>
</p><p><a rel="nofollow" class="external text" href="https://github.com/EpicGames/UnrealTournament/blob/clean-master/UnrealTournament/Source/UnrealTournament/Public/UTCharacter.h">UTCharacter.h</a>
</p><p><a rel="nofollow" class="external text" href="https://github.com/EpicGames/UnrealTournament/blob/clean-master/UnrealTournament/Source/UnrealTournament/Private/UTCharacter.cpp">UTCharacter.cpp</a>
</p><p><a rel="nofollow" class="external text" href="https://github.com/EpicGames/UnrealTournament/blob/clean-master/UnrealTournament/Source/UnrealTournament/Private/UTCharMovementReplication.cpp">UTCharMovementReplication.cpp</a>
</p><p><br />
<a href="index2007.html?title=User:DarthCoder&amp;action=edit&amp;redlink=1" class="new" title="User:DarthCoder (page does not exist)">DarthCoder</a> (<a href="index7570.html?title=User_talk:DarthCoder&amp;action=edit&amp;redlink=1" class="new" title="User talk:DarthCoder (page does not exist)">talk</a>)
</p>
<!-- 
NewPP limit report
Cached time: 20200401004700
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.088 seconds
Real time usage: 1.321 seconds
Preprocessor visited node count: 257/1000000
Preprocessor generated node count: 556/1000000
Post‐expand include size: 20/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.931      1 -total
100.00%    0.931      1 Template:Rating
-->
</div>
<!-- Saved in parser cache with key wiki_pd05v2:pcache:idhash:160-0!canonical and timestamp 20200401004658 and revision id 321
 -->
</div>						<div class="printfooter">
							Retrieved from "<a dir="ltr" href="index856d.html?title=Authoritative_Networked_Character_Movement&amp;oldid=321">https://mediawikiv2-website-prod05.ol.epicgames.net/index.php?title=Authoritative_Networked_Character_Movement&amp;oldid=321</a>"						</div>
					<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="indexecb1.html?title=Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="indexb3b2.html?title=Category:Tutorials&amp;action=edit&amp;redlink=1" class="new" title="Category:Tutorials (page does not exist)">Tutorials</a></li><li><a href="indexdd0a.html?title=Category:Code" title="Category:Code">Code</a></li><li><a href="index1db6.html?title=Category:Community_Created_Content" title="Category:Community Created Content">Community Created Content</a></li></ul></div></div>					<div class="visualClear"></div>
									</div>
			</div>
		</div>
		<div id="eg-footer" role="contentinfo">
			<!DOCTYPE html><html data-baseurl="https://www.unrealengine.com"><head><meta charSet="UTF-8"><meta httpEquiv="X-UA-Compatible" content="IE=9;IE=10;IE=11;IE=Edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui"><meta name="host" content="ue-website-node-prod07-i-0d0405fab30c4bd94"><meta name="worker" content="206"><link rel="apple-touch-icon" sizes="180x180" href="indexfb0b.html"><link rel="icon" type="image/png" sizes="32x32" href="index4aa2.html"><link rel="icon" type="image/png" sizes="16x16" href="indexca83.html"><link rel="manifest" href="index38c2.html"><link rel="mask-icon" href="indexebf0.html" color="#2a2a2a"><meta name="apple-mobile-web-app-title" content="Unreal Engine"><meta name="application-name" content="Unreal Engine"><meta name="msapplication-TileColor" content="#0aaff1"><meta name="msapplication-TileImage" content="/mstile-144x144.png"><meta name="theme-color" content="#0aaff1"><title data-react-helmet="true"></title></head><body><div id="epicGamesFooter"></div><script>window._epicGamesFooter = {"serverUrl":"https://www.unrealengine.com","socialLinks":[{"_type":"Epic Footer Social Link","id":"twitter","href":"https://twitter.com/unrealengine"},{"_type":"Epic Footer Social Link","id":"facebook","href":"https://www.facebook.com/UnrealEngine"},{"_type":"Epic Footer Social Link","href":"http://www.twitch.tv/unrealengine","id":"twitch"},{"_type":"Epic Footer Social Link","id":"instagram","href":"http://instagram.com/UnrealEngine"},{"_type":"Epic Footer Social Link","href":"http://www.youtube.com/unrealengine","id":"youtube"},{"_type":"Epic Footer Social Link","href":"https://www.unrealengine.com/rss","id":"rss"}],"_currentVersion":"1.89","copyrights":["© 2004-{YEAR}, Epic Games, Inc. All rights reserved. Unreal and its logo are Epic’s trademarks or registered trademarks in the US and elsewhere."],"newsLetterConfigs":{"enableNewsLetterCMS":true,"titleMsg":"Sign up for Unreal Engine news!","btnTxt":"Subscribe","_type":"Epic Footer News Letter","logo":"https://cdn2.unrealengine.com/Unreal+Engine%2FUE-Logo-988x988-1dee3bc7f6714edf3c21ee71826ebab54ae02077.png","successMsg":"You have successfully subscribed to Unreal Engine Newsletter.","loginRequired":false},"legalTags":[],"_type":"Epic Games Footer","newLineCopyrights":false,"_lastModifiedBy":"tony.rossi","epicPropertyName":"unreal_engine","_createdBy":"tony.rossi","_uuid":"dbad9ee8-9ebd-49e5-a448-e930feda5b65","logos":[{"_type":"Epic Footer Logo","href":"https://www.epicgames.com?lang=en-US","id":"eg","title":"Epic Games"},{"_type":"Epic Footer Logo","id":"ue","href":"https://www.unrealengine.com"}],"callToAction":{"_type":"Epic Header Call To Action","useCustomCallback":false,"title":""},"_futureVersion":"none","_created":"2017-08-21T08:59:33.817Z","messages":{"_type":"Epic Footer Messages","tos":"Terms of Service","privacy":"Privacy Policy"},"links":[{"_type":"Epic Footer Link","useCustomCallback":true,"href":"http://unrealengine.com/features","title":"Features"},{"_type":"Epic Footer Link","useCustomCallback":true,"href":"http://unrealengine.com/branding","title":"Logo & Branding"},{"_type":"Epic Footer Link","useCustomCallback":false,"href":"https://trello.com/b/TTAVI7Ny/ue4-roadmap","title":"Roadmap"},{"_type":"Epic Footer Link","useCustomCallback":true,"href":"http://unrealengine.com/education","title":"Education"},{"_type":"Epic Footer Link","useCustomCallback":true,"href":"http://unrealengine.com/academic-partners-apply","title":"Academic Partners"},{"_type":"Epic Footer Link","useCustomCallback":true,"href":"http://unrealengine.com/resources","title":"More Resources"},{"_type":"Epic Footer Link","useCustomCallback":true,"href":"http://unrealengine.com/awards","title":"Awards"},{"_type":"Epic Footer Link","useCustomCallback":true,"href":"http://unrealengine.com/custom-licensing","title":"Custom License Terms"},{"_type":"Epic Footer Link","useCustomCallback":false,"href":"https://dev.epicgames.com","title":"Online Services"},{"_type":"Epic Footer Link","useCustomCallback":true,"href":"http://unrealengine.com/training-partners","title":"Training Partners"},{"_type":"Epic Footer Link","useCustomCallback":false,"href":"https://www.epicgames.com/site/community-rules","title":"Community Rules"}],"hideDefaultTermsPolicy":false,"_lastModified":"2020-03-20T13:39:17.770Z","_version":{"_comment":"Publish The Common Content Type to server ","_createdBy":"tony.rossi"},"_locale":"en_US","isEu":false,"useServerUrl":true};
window.__locale = '';
</script><link key="footer-css" rel="stylesheet" href="../static-assets-prod.epicgames.com/unrealengine/static/webpack/footer.epic-unreal-engine.5ace4ab88c6f6357685f.css"><script src="../static-assets-prod.epicgames.com/unrealengine/static/webpack/footer.epic-unreal-engine.5ace4ab88c6f6357685f.js"></script></body></html>		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.088","walltime":"1.321","ppvisitednodes":{"value":257,"limit":1000000},"ppgeneratednodes":{"value":556,"limit":1000000},"postexpandincludesize":{"value":20,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"timingprofile":["100.00%    0.931      1 -total","100.00%    0.931      1 Template:Rating"]},"cachereport":{"timestamp":"20200401004700","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":93});});</script>
	<script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"beacon":"bam.nr-data.net","licenseKey":"93a8bd5691","applicationID":"145396307","transactionName":"MlxXbUBZWkJUAkVQCgsWdFpGUVtfGgBSTQwKVxpPW11D","queueTime":0,"applicationTime":136,"atts":"HhtUGwhDSUw=","errorBeacon":"bam.nr-data.net","agent":""}</script></body>
</html>
